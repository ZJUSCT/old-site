{"meta":{"title":"浙江大学超算队","subtitle":"Zhejiang University Supercomputer Team","description":"Official Blog Of ZJUSCT","author":"ZJUSCT","url":"http://clusters.zju.edu.cn","root":"/"},"pages":[{"title":"关于世界大学生超级计算机竞赛(ASC\\ISC\\SC)","date":"2018-10-01T07:12:16.000Z","updated":"2019-05-12T02:30:58.533Z","comments":true,"path":"about/index.html","permalink":"http://clusters.zju.edu.cn/about/index.html","excerpt":"","text":"竞赛目的ASC超算竞赛旨在通过大赛的平台推动各国及地区间超算青年人才交流和培养，提升超算应用水平和研发能力，发挥超算的科技驱动力，促进科技与产业创新。吸引本科生参加超级计算机竞赛以培养学生在超算并行、高性能计算方面的动手实践能力，促进课程理论知识与实践能力的结合。 竞赛内容竞赛总共由数道题目组成, 每一道赛题都是对现代科学难题的挑战，需要考验参赛队伍的分析解决问题以及团队协同作战的综合能力。比赛要求每个队伍完成超级计算机集群的设计与搭建，要求选手必须要具备驾驭计算机软硬件操作系统的整体能力，还要在自搭建的集群计算机系统上完成面向前沿科技领域难题的科学应用软件的高性能优化，要具备程序并行优化编码能力。竞赛分为多个流程：理论方案、设计模型、实现、现场展示、答辩等。 奖项设置 ASC 超算竞赛： 总冠军、亚军各1 项，ePrize 奖1 项（季军），最高计算性能HPL 冠军，最佳应用创新奖，最佳应用奖，最佳呈现奖及一等奖若干 ISC/SC 超算竞赛： 总冠军一名，授予在整体算例以及现场呈现过程中得分最高的队伍。最高计算性能：HPL 单项冠军一名，授予HPL 比赛成绩最高的队伍。最受欢迎奖一名，授予比赛期间得到ISC 参会者投票最多的队伍。难度一样，规模比ASC稍小。 浙江大学历年成绩 ASC2014 世界大学生超级计算机竞赛一等奖 ASC2015 世界大学生超级计算机竞赛一等奖 ASC2016 世界大学生超级计算机竞赛一等奖 ASC2016 世界最高计算性能冠军奖 ASC2016 世界最高计算性能打破世界纪录 ASC2018 世界大学生超级计算机竞赛初赛第四名 决赛一等奖 超算队还开设短学期课程 超算团队与信息安全竞赛、系统设计能力竞赛、程序设计竞赛一起，共同推进以计算机系统能力为基础的人才培养改革与课程建设。超算基地近5 年来的人才培养与成果积累，参与申报2017 年“系统能力建设教学成果奖评比”项目，获浙江省教学成果一等奖。与ACM算法竞赛同为浙江大学世界级学科竞赛项目 拥有保研名额。"},{"title":"Team Introduction","date":"2018-11-05T05:01:49.000Z","updated":"2019-05-12T02:30:58.550Z","comments":true,"path":"teamIntro/index.html","permalink":"http://clusters.zju.edu.cn/teamIntro/index.html","excerpt":"","text":"超算队成员介绍 姓名 毕业年份 去向分类 去向 备注 何宇 2018 出国留学 美国 卡内基梅隆大学 硕士 单挺 创业 杭州马猴烧韭科技有限公司 公司已获得300万元融资 徐启源 2017 国内深造 浙江大学 硕士 朱鼎含 2017 出国留学 美国 南加州大学 硕士 陈星眸 2018 工作 曹舒翔 2018 出国留学 英国 牛津大学 博士 凝聚态物理学 超导量子计算方向 邢畅 2016 出国留学 美国东北大学 硕士 Facebook工作 弓得力 2016 出国留学 新加坡国立大学 区块链公司（Zilliqa）工作 费翔 2016 国内深造 清华大学 巩炳辰 2016 国内深造 香港大学 计算机视觉方向 于振云 2019 计算机科学与技术 阿里巴巴实习 吴凡 2019 电气工程与自动化 华为实习 施歌 2020 2016级中加班中方生 杨玄达 2020 计算机科学与技术(何志均班) 孙耀珠 2019 求是科学班(计算机) 菅浩然 2020 计算机科学与技术 陈岩 2020 数字媒体技术 袁谱博 2020 信息安全 俞炯弛 2021 高分子科学与工程 王克 2021 计算机科学与技术 黄启涵 2021 软件工程 康嘉成 2021 计算机科学与技术 林柯舟 2021 计算机科学与技术 漆翔宇 2021 计算机科学与技术 沈韬立 2021 信息安全 夏豪诚 2021 信息安全 张文捷 2021 计算机科学与技术 陈谋祥 2021 计算机科学与技术 潘薇鸿 2021 测控技术与仪器 朱璟森 2021 计算机科学与技术 张震铄 2021 计算机科学与技术 超算队指导老师介绍陈建海老师 陈建海，博士，浙江大学计算机学院。浙江大学计算机学院智能计算&amp;系统实验室（InCAS-LAB）区块链负责人，IEEE、ACM、CCF会员。研究领域：计算机体系结构领域，涉及云计算、虚拟化、区块链，擅长区块链系统性能与安全，虚拟计算系统性能优化与调度，高性能计算并行应用优化，近似算法与博弈论运用等。 负责区块链、高性能计算方面的重点研发项目子课题2项，参与完成多项云计算虚拟化相关的国家科技部支撑计划、国家基金以及企业合作项目。累计发表SCI/EI论文15篇，申请授权专利超过30项。 第44界世界技能大赛网站设计项目浙江省技术专家组组长，国家级裁判，带领浙江省队员获44界世界技能大赛全国选拔赛第四名。主持Designer项目获2018全球迅雷区块链应用开发大赛第一名。 沈钦仙老师 学校支持 设备介绍计算机学院超算竞赛基地 吸引本科生参加超级计算机竞赛以培养学生在超算并行、高性能计算方面的动手实践能力，促进课程理论知识与实践能力的结合 开设暑期超算集训短学期课程 学院提供超算竞赛基地，支持每年8万元经费 硬件强支撑：学校与学院支持建有13节点百万超算集群，含GPU\\MAC卡等异构设备 赞助与合作介绍 ASC2016 获英伟达硬件Tesla GPU K80 加速卡硬件赞助 ASC2018获AMAX 赞助借用硬件Tesla GPU V100 8块 ······"},{"title":"Contact Us!","date":"2018-12-08T12:42:52.000Z","updated":"2019-05-12T02:30:58.548Z","comments":true,"path":"contact/index.html","permalink":"http://clusters.zju.edu.cn/contact/index.html","excerpt":"","text":"Send your email and Join ZJUSCT now!window.location.href =\"mailto:jiongchiyu@zju.edu.cn\""}],"posts":[{"title":"基于0-1乘性噪声的朴素图片降噪","slug":"Image-Restoration-SimpleVersion","date":"2019-05-10T16:00:00.000Z","updated":"2019-05-12T02:02:44.718Z","comments":true,"path":"2019/05/11/Image-Restoration-SimpleVersion/","link":"","permalink":"http://clusters.zju.edu.cn/2019/05/11/Image-Restoration-SimpleVersion/","excerpt":"","text":"基于0-1乘性噪声的图片降噪 项目内容给定3张受损图像，尝试恢复他们的原始图像。 原始图像包含1张黑白图像（A.png）和2张彩色图像（B.png, C.png）。 受损图像$X$是由原始图像$I \\in R ^ { H * W * C }$添加了不同噪声遮罩$M \\in R ^ { H * W * C }$得到的$x=I \\odot m$，其中$ \\odot $是逐元素相乘。 噪声遮罩仅包含{0,1}值。对应原图（A/B/C）的噪声遮罩的每行分别用0.8/0.4/0.6的噪声比率产生的，即噪声遮罩每个通道每行80%/40%/60%的像素值为0，其他为1。 评估误差为恢复图像与原始图像向量化后的差向量的2-范数，此误差越小越好。 实现介绍 核心思想由于图片的像素点在空间上满足局部相似的特征，相邻的像素点通道值变化往往是平滑且有一定规则的。因此，我们可以用一个模型来拟合像素点通道值在空间上的关系。具体实现中，我们将图片切割成若干个小矩形块，然后使用一个二维线性回归模型来回归每个小矩形块中位置和像素通道值的函数关系。为了使结果更加平滑和可靠，我们采用了高斯函数作为基函数。 高斯函数当我们对一个 ss * ss 的像素矩阵块做回归的时候，我们要把所有没有被噪音损坏的点都提取出来。点位置用一个高斯核函数处理，这样原来的点坐标(x,y)就被转换成了$(e^{-\\frac{(x-mid)^2}{2}},e^{-\\frac{(y-mid)^2}{2}})$，在特征空间中用来刻画这个点与矩阵块中心的距离。这样，我们实际要回归的就是点心距与像素通道值的关系。 这样做，主要是因为我们的局部性原理本身就是不带方向性的，所谓的局部性就是指临近的点存在某种平滑的变化关系。使用这样一个衡量距离的核函数，可以使得我们的回归结果更加平滑： 上图左边是用坐标直接回归，右图是坐标经过高斯核处理后回归的结果。可以看到左边有大量的不平滑的交错的黑白点，看起来很“脏”。右边由于采用了高斯函数处理过的表征距离关系的核函数，结果更加平滑，清晰。 CODE : 训练提取完特征后的数据点拟合，就是一个简单的线性回归任务而已，我们采用最小二乘法回归。$$Loss = \\frac {\\Sigma_{i=0}^n(y_i-\\phi(x_i) * w^T)^2}{n}=\\frac{\\Sigma_{i=1}^{n}Loss_i}{n}$$使用随机梯度下降来最优化损失函数：$$w\\leftarrow w-\\eta * \\triangledown Loss_i=w+2\\eta(y_i-\\phi(x_i) * w^T) * \\phi(x_i)$$具体实现中，我们取步长=0.005，进行100轮随机梯度下降。 CODE : ​ 迭代降噪我们前面提到了，我们要把图片切成若干个小矩形块，对每个小矩形块分别进行回归，那么这个小矩形块的尺寸取多少比较合适呢？ 我们先取ss=2尝试一下： 噪音为0.8的时候，我们可以看到，如果取一个2*2的块，期望其中没损坏的通道只有0.8个，所以势必有大量的矩阵块里面都是全损坏的，这会使得一些全损坏的块得不到修复，产生大量的黑点。 直接取ss=5： 显然，黑块的数量变少了，但是实际上图片给人的颗粒赶很明显，更像是一堆模糊的马赛克拼图拼凑而成的。 我们的解决办法是先取ss=2，对图片做恢复，然后将恢复的图像再用更大的ss来恢复。 下面是用ss={2，3，4，5}迭代恢复四次的过程： 可以看到黑点逐渐被消除，并且最后经过ss=5的回归后得到的结果在视觉效果上明显优于直接用ss=5进行回归。这种想法本质上是一种贪心算法。先将损失密度小的局部块恢复好，再充分利用之前修复出来的信息将损失密度更大的块修复。 实验结果A （noise rate = 0.8） B（noise rate = 0.4） C（noise rate = 0.6） D（根据原图自己生成，测试迭代过程中损失的减少） 潜在的优化展望 由于每个块的修复是独立的，可以考虑使用CPU多线程计算或者在GPU上用CUDA进行并行优化，加速整个修复过程。 使用更复杂的网络来拟合。 使用马尔科夫随机场的方法来做图像降噪。","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"http://clusters.zju.edu.cn/tags/AI/"}],"author":"漆翔宇"},{"title":"Virtual Memory and TLB","slug":"Virtual-Memory-and-TLB","date":"2019-03-31T06:05:11.000Z","updated":"2019-05-12T02:30:58.482Z","comments":true,"path":"2019/03/31/Virtual-Memory-and-TLB/","link":"","permalink":"http://clusters.zju.edu.cn/2019/03/31/Virtual-Memory-and-TLB/","excerpt":"","text":"Virtual Memory and TLB虚拟地址空间x86 CPU 的地址总选宽度为32位，理论寻址上限为4GB。而虚拟地址空间的大小就是4GB，占满总线，且空间中的每一个字节分配一个虚拟地址 其中高2G0x80000000 ~ 0xFFFFFFFF为内和空间，由操作系统调用； 低2G0x00000000 ~ 0x7FFFFFFF为用户空间，由用户使用。 在系统中运行的每一个进程都独自拥有一个虚拟空间，进城之间的虚拟空间不共用。 虚拟地址空间是一种通过机制映射出来的空间，与实际物理空间大小无必然联系，在x86保护模式下，无论计算及实际主存是512MB还是8GB，虚拟地址空间总是4GB，这是由CPU和操作系统的宽度决定的，即： CPU地址总线宽度 → 物理地址范围CPU的ALU宽度 → 操作系统位数 → 虚拟地址范围 虚拟内存虚拟地址空间 = 主存 + 虚拟内存(交换空间 Swap Space) 虚拟内存：将硬盘的一部分作为存储器使用，来扩充物理内存。 利用了自动覆盖、交换技术。内存中存不下、暂时不用的内容会存在硬盘中。 Assume: 32位操作系统，32位寻址总线宽度 → 4G线性空间 保护模式下的进程运行虚拟地址空间是硬件行为，CPU自动完成(同时与操作系统协作)虚拟地址到物理地址(可能差熬过实际内存，这样会产生一个异常中断，揭晓来有操作系统处理(如从虚拟内存中调出对应的页框内容))。 所以，一个程序若运行在保护模式下，其汇编级、机器语言级的寻址都是用的虚拟地址，即在一般的编程中不会接触到物理一层。 在进程被加载时，系统为进程建立唯一的数据结构进程控制块(PCB = Process Control Block)，直至进程结束。 PCB中描述了该进程的现状以及控制运行的全部信息，有了PCB，一个进程才可以在保护模式下和其他进程一起被并发地运行起来，操作系统通过PCB对进程进行控制。 PCB中的程序ID(PID(unix、linux)、句柄(windows))是进程的唯一标识；PCB中的一个指针指向 页表 ，这些都与地址转化有关。 地址转化地址转化的全过程可以用以下这张图来概括： 以下是具体步骤介绍。 1. 逻辑地址 → 线性地址 (段式内存管理，Intel早期策略的保留) 段内偏移地址(32位) 段选择符：16位长的序列，是索引值，定位段描述符；结构： 高13位为表内索引号 —— 但注意由于GDT第一项留空，所以索引要先加1； 而2位为TI表指示器，0是指GDT，1是指LDT； 0、1位是RPL请求者特权级，00最高，11最低 —— 在x86保护模式下修改寄存器是系统之灵，必须有对应的权限才能修改(当前执行权限和段寄存器中(被修改的)的RPL均不低于目标段的RPL) 段描述符：8x8=64位长的结构，用来描述一个段的各种属性。结构： 0、1字节+6字节低4位(20位) 段边界/段长度：最大1MB或者4G(看粒度位的单位) 2、3、4、7字节(32位) 段基址：4G线性地址的任意位置(不一定非要被16整除) 6、7字节的奇怪设计是为了兼容80286(24位地址总线) 剩下的那些是段属性，详见20180819143434 段描述表：多任务操作系统中，含有多个任务，而每个人物都有多个段，其段描述符存于段描述表中。IA-32处理器有3个段描述表：GDT、LDT和IDT。 GDT(Global Descripter Table) 全局段描述符表：一个系统一般只有一个GDT，含有每一个任务都可以访问的段；通常包含操作系统所使用的代码段、数据段和堆栈段，GDT同时包含各进程LDT数据段项，以及进程间通讯所需要的段。GDTR是CPU提供的寄存器，存储GDT的位置和边界；在32位模式下RGDT有48位长(高32位基地址+低16位边界)，在32e模式下有80位长(高64位基地址+低16位边界)。GDT的第一个表项留空不用，是空描述符，所以索引号要加1。GDT最多128项。 LDT(Local Descripter Table) 局部段描述符表：16位长，属于某个进程。一个进程一个LDT，对应有RLDT寄存器，进程切换时RLDT改变。RLDT和RGDT不一样，RLDT是一个索引值而不是实际指向，指向GDT中某一个LDT描述项。所以如果要获取LDT中的某一项，先要访问GDT找到对应LDT，再找到LDT中的一项。编译程序时，程序内赋予了虚拟页号。在程序运行时，通过对应LDT转译成物理地址。故虚拟页号是局部性的、不同进程的页号会有冲突。LDT没有空选择子。 IDT(Interrupt Descripter Table) 中断段描述符表；一个系统一般也只有一个。 以下这个图能做一点解释： 2. 线性地址 → 物理地址 (页式内存管理)这一步由CPU的页式管理单元来负责转换。——MMU(内存管理单元)。 线性地址可以拆分为三部分(或者两部分)： 页(Page)：线性地址被划分为大小一致的若干内存区域，其对应映射到大小相同的与物理空间区域页框(Frame)上。这个映射不一定是连贯而有序的。 CR3：页目录基址寄存器。对于每一个进程，CR3的内容不同(有点像RLDT)，页目录基址也不同，线性地址-物理地址的映射也不同。 页目录：占用一个4kb的内存页，最多存储1024个页目录表项(PDE)，一个PDE有4字节。在没启用PAE时，有两种PDE，规格不同。 页目录表项(PDE)：每个程序有多个页表，即拥有多个PDE。PDE的结构如下：12~31位(20位)表示页表起始物理地址的高20位(页表基址低12位为0，即一定以4kb对齐)。 页表：一个页表占4kb的内存页，最多存储1024个页表项(PTE)，一个PTE是4字节。页表的基址是4kb对齐的，低12位是0。 采用对页表项的二级管理模式(也目录→页表→页)能够节约空间。因为不存在的页表就可以不分配空间，并且对于Windows来说只有一级页表才会存在主存中，二级可以存在辅存中——不过Linux中它们都常驻主存。 一些CPU会提供更多级的架构，如三级、四级。Linux中，有对应的高层次抽象，提供了一个四层页管理架构：把中间的某几个定为长度为0，就可以调整架构级数。如“四化二”：某地址0x08147258，对应的PUD、PMD里只有一个表项为PUD→PMD，PMD→PT；划分的时候，PGD=0000100000，PUD=PMD=0，PT=0101000111. 3. TLB (转换检测缓冲区、快表、转译后被缓冲区)处理器中，一个具有并行朝赵能力的特殊高速缓存器，存储最近访问过的一些页表项(时空局部性原理，减少页映射的内存访问次数)。 TLB较贵，通常能够存放16~512个页表项。 TLB命中：直接取出对应的页表项 TLB缺失：先淘汰TLB中的某一项(TLB替换策略，一些算法，可以由硬件或软件来实现) 硬件处理TLB Miss：CPU会遍历页表，找到正确的PTE；如果没有找到，CPU就会发起一个页错误并将控制权交给操作系统。 软件处理TLB Miss：CPU直接发出未命中错误，让操作系统来处理。 脏记录：当TLB中某个PTE项失效(如切换进程、进程退出、虚拟页换出到磁盘)，PTE标记为不存在，此时映射已经不成立了。操作系统要保证即时刷新掉这些脏记录，不同的CPU有不同的刷新TLB方法，但每次都完全刷新TLB会很慢，所以现在有一些策略，扩展对一个PTE的描述(如针对某个进程、空间的标识，如果目前进程与PTE相关，就会忽略掉)，这样可以让多个进程同时共存TLB Linux 段式管理Linux似乎没有理会Intel的那一套段的机制，而是做了一个高级的抽象。Linux对所有的进程使用了相同的段来对指令和数据寻址，让每个段寄存器都指向同一个段描述符，让这个段描述符的基址为0，长度为4G。即用这种方式略去了段式内存管理。对应多有用户代码段、用户数据段、内核代码段和内核数据段。可以在segment.h中看到，四种段对应的段基址都是0，这就是“平坦内存模型”，这样就有段内偏移地址=逻辑地址 且，四种段对应的都为GDT。即Linux大多数情况都不使用LDT，除非使用wine等Windows防真程序。 Linux 0.11中每个进程划分64MB的虚拟内存空间。故逻辑地址范围为0~0x4000000","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"http://clusters.zju.edu.cn/tags/Tech/"},{"name":"Operating Susyem","slug":"Operating-Susyem","permalink":"http://clusters.zju.edu.cn/tags/Operating-Susyem/"},{"name":"Virtual Memory","slug":"Virtual-Memory","permalink":"http://clusters.zju.edu.cn/tags/Virtual-Memory/"},{"name":"TLB","slug":"TLB","permalink":"http://clusters.zju.edu.cn/tags/TLB/"}],"author":"王克"},{"title":"如何在墙内快速部署CentOS 7的MySQL","slug":"Install-MySQL-on-CentOS7-Inside-GFW","date":"2019-03-31T02:45:19.000Z","updated":"2019-05-12T02:30:58.481Z","comments":true,"path":"2019/03/31/Install-MySQL-on-CentOS7-Inside-GFW/","link":"","permalink":"http://clusters.zju.edu.cn/2019/03/31/Install-MySQL-on-CentOS7-Inside-GFW/","excerpt":"","text":"如何在墙内快速部署CentOS 7的MySQLMySQL 被 Oracle 收购后，CentOS 的镜像仓库中提供的默认的数据库也变为了 MariaDB，所以默认没有 MySQL ，需要手动安装。 其实安装 MySQL 也并不是一件很难的事情，但是由于一些实际存在的问题(比如某墙)，让默认通过 yum 安装 MySQL 的速度太慢。这里提出一种可行的方案来快速部署 MySQL ，此方案同样适用于其他 rpm 包软件的手动安装。 本文实际在讲的是，如何利用各种手段，加速和改善yum的安装过程。 传统方案……慢到怀疑人生根据官方指南，我们执行如下命令： 123456# 下载源wget \"https://dev.mysql.com/get/mysql80-community-release-el7-2.noarch.rpm\"# 安装源sudo rpm -ivh mysql80-community-release-el7-2.noarch.rpm# 检查源是否成功安装sudo yum repolist enabled | grep \"mysql80-community*\" 接下来就是正常的安装步骤： 1sudo yum install mysql-community-server mysql 但是由于一些原因，下载速度基本是几Byte/s，MySQL 服务器的大小(加上依赖服务)差不多有600MB，这种方法基本不可取。手头没有特别好的而且很新的软件源，就打算手动安装。 手动安装法首先依然需要下载并安装官方源。 1yum install mysql-community-server 利用该命令我们可以获取一些 MySQl Server 以来安装顺序及其版本： 1234567891011121314================================================================================================= Package Arch Version Repository Size=================================================================================================Reinstalling: mysql-community-client x86_64 8.0.15-1.el7 mysql80-community 25 M mysql-community-libs x86_64 8.0.15-1.el7 mysql80-community 2 M mysql-community-common x86_64 8.0.15-1.el7 mysql80-community 570 K mysql-community-server x86_64 8.0.15-1.el7 mysql80-community 360 MTransaction Summary================================================================================================= 解压并分析rpm源包： 12rpm2cpio mysql80-community-release-el7-2.noarch.rpm | cpio -divvim /etc/yum.repos.d/mysql-community.repo 从中我们可以找到对应版本的网络路径为http://repo.mysql.com/yum/mysql-8.0-community/el/7/x86_64/。 打开该地址，找到对应的几个安装包： mysql-community-client-8.0.15-1.el7.x86_64.rpm mysql-community-libs-8.0.15-1.el7.x86_64.rpm mysql-community-common-8.0.15-1.el7.x86_64.rpm mysql-community-server-8.0.15-1.el7.x86_64.rpm 使用某种下载工具(我使用的是迅雷)下载，然后使用scp指令上传到服务器上： 1234scp mysql-community-client-8.0.15-1.el7.x86_64.rpm xxx@xx.xx.xx.xx:/root/mysql-community-client-8.0.15-1.el7.x86_64.rpmscp mysql-community-libs-8.0.15-1.el7.x86_64.rpm xxx@xx.xx.xx.xx:/root/mysql-community-libs-8.0.15-1.el7.x86_64.rpmscp mysql-community-common-8.0.15-1.el7.x86_64.rpm xxx@xx.xx.xx.xx:/root/mysql-community-common-8.0.15-1.el7.x86_64.rpmscp mysql-community-server-8.0.15-1.el7.x86_64.rpm xxx@xx.xx.xx.xx:/root/mysql-community-server-8.0.15-1.el7.x86_64.rpm 按照先后顺序依次执行yum本地安装： 123456sudo yum localinstall mysql-community-common-8.0.15-1.el7.x86_64.rpmsudo yum localinstall mysql-community-libs-8.0.15-1.el7.x86_64.rpmsudo yum localinstall mysql-community-client-8.0.15-1.el7.x86_64.rpmsudo yum localinstall mysql-community-server-8.0.15-1.el7.x86_64.rpmsudo yum -y install mysql 安装成功，启动并测试服务： 12systemctl start mysqld.servicesystemctl status mysqld.service 找出默认密码： 1grep &quot;password&quot; /var/log/mysqld.log &gt;&gt; defalut_mysql_passwd.txt","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://clusters.zju.edu.cn/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://clusters.zju.edu.cn/tags/CentOS/"}],"author":"王克"},{"title":"BP算法","slug":"bp","date":"2018-12-24T13:03:59.000Z","updated":"2019-05-12T02:30:58.501Z","comments":true,"path":"2018/12/24/bp/","link":"","permalink":"http://clusters.zju.edu.cn/2018/12/24/bp/","excerpt":"","text":"Feed forward neural network and back propagation1. Neuron structure 上图是一种典型的神经元结构，$x_n$是神经元的输入，将输入加权求和后再通过激活函数即可得到此神经元的输出：$$t = \\sum_{i=1}^{n}{w_ix_i} + b$$$$a = f(t)$$ 为计算方便，可将偏置$b$提到求和符号里面，相当于加入一个恒为1的输入值，对应的权重为$b$：$$t = \\sum_{i=0}^{n}{w_ix_i},(x_0 = 1, w_0 = b)$$$$a = f(t)$$此即为上图神经元结构对应的表达式 常用的激活函数有sigmoid, ReLU, tanh等。 2. Network structure 这是一个简单的3层网络，输入层有3个输入值，隐藏层包含3个隐藏神经元，最后是两个输出值隐藏层神经元的前向计算过程： $$z_i^{l} = \\sum_{i=0}^{n}w_{ij}^{l}x_j, (x_0 = 1, w_0 = b)$$ $$a_i^l = f(z_i^l)$$ $l$表示第几层。 这个网络的抽象数学表达式为：$$F(x) = f_3(f_2(x * W_2 + b_2) * W_3 + b_3)$$ 事实上，深度神经网络一般都能够抽象为一个复合的非线性多元函数，有多少隐藏层就有多少层复合函数：$$F(x) = f_n\\left(\\dots f_3(f_2(f_1(x) * w_1 + b_1) * w_2 + b_2)\\dots\\right)$$ 3. LossLoss，即损失，用来衡量神经网络的输出值与实际值的误差，对于不同的问题，通常会定义不同的loss函数 回归问题常用的均方误差：$$MSE = \\frac{1}{n}\\sum_{i=1}^{n}(Y - f(x))^2$$$Y$为实际值，$f(x)$为网络预测值 分类问题常用的交叉熵(m类)：$$L = \\sum_{k=1}^{n}\\sum_{i=1}^{m}l_{ki}log(p_{ki})$$$l_{ki}$表示第k个样本实际是否属于第i类（0，1编码），$p_{ki}$表示第k个样本属于第i类的概率值 特别地，二分类问题的交叉熵损失函数形式为：$$L = \\sum_{i=1}^{n}[y_ilog(p_i) + (1 - y_i)log(1 - p_i)]$$$y_i$为第i个样本所属类别，$p_i$为第i个样本属于$y_i$类的概率 4. Back propagationBP 是用来将loss反向传播的算法，用来调整网络中神经元间连接的权重和偏置，整个训练的过程就是：前向计算网络输出-&gt;;根据当前网络输出计算loss-&gt;BP算法反向传播loss调整网络参数，不断循环这样的三步直到loss达到最小或达到指定停止条件 BP算法的本质是求导的链式法则，对于上面的三层网络，假设其损失函数为$C$，激活函数为$\\sigma$，第$l$第$i$个神经元的输入为$z_i^{(l)}$，输出为$a_i^{(l)}$ 则通过梯度下降来更新权值和偏置的公式如下：$$W_{ij}^{(l)} = W_{ij}^{(l)} - \\eta\\frac{\\partial}{\\partial W_{ij}^{(l)}}C\\tag1$$$$b_{i}^{(l)} = b_{i}^{(l)} - \\eta\\frac{\\partial}{\\partial b_{i}^{(l)}}C\\tag2$$ $W_{ij}^{(l)}$表示第$l$层第$i$个神经元与第$l - 1$层第$j$个神经元连接的权值，$b_i^{(l)}$表示第$l$层第$i$个神经元的偏置 $\\eta$表示学习率 由更新公式可见主要问题在于求解损失函数关于权值和偏置的偏导数 第$l$层第$i$个神经元的输入$z_i^{(l)}$为：$$z_i^{(l)} = \\sum_{j=1}^{n^{(l-1)}}{W_{ij}^{(l)}a_j^{(l-1)}} + b_i^{l}\\tag3$$ 则更新公式中偏导项可化为: $$\\frac{\\partial}{\\partial W_{ij}^{(l)}}C = \\frac{\\partial C}{\\partial z_i^{(l)}} \\bullet \\frac{\\partial z_i^{(l)}}{\\partial W_{ij}^{(l)}} = \\frac{\\partial C}{\\partial z_i^{(l)}} \\bullet a_i^{(l-1)}\\tag4$$ $$\\frac{\\partial}{\\partial b_{i}^{(l)}}C = \\frac{\\partial C}{\\partial z_i^{(l)}} \\bullet \\frac{\\partial z_i^{(l)}}{\\partial b_{i}^{(l)}} = \\frac{\\partial C}{\\partial z_i^{(l)}}\\tag5$$ 定义 $$\\delta_i^{(l)} = \\frac{\\partial}{\\partial z_i^{(l)}}C\\tag6$$ 现在问题转化为求解$\\delta_i^{(l)}$，对第$l$层第$j$个神经元有：$$\\delta_j^{(l)} = \\frac{\\partial C}{\\partial z_j^{(l)}} = \\sum_{i=1}^{n^{(l+1)}}\\frac{\\partial C}{\\partial z_i^{(l+1)}} \\bullet \\frac{\\partial z_i^{(l+1)}}{\\partial a_j^{(l)}} \\bullet \\frac{\\partial a_j^{(l)}}{\\partial z_j^{(l)}} \\=\\sum_{i=1}^{n^{(l+1)}}\\delta_i^{(l+1)} \\bullet \\frac{\\partial(W_{ij}^{l+1} + b_i^{(l+1)})}{\\partial a_j^{(l)}} \\bullet \\sigma^\\prime(z_j^{(l)})\\=\\sum_{i=1}^{n^{(l+1)}}\\delta_i^{(l+1)} \\bullet W_{ij}^{(l+1)} \\bullet \\sigma^\\prime(z_j^{(l)})\\tag7$$ 则：$$\\delta^{(l)} = ((W^{(l+1)})^T\\delta^{(l+1)})\\odot\\sigma^\\prime(z^{(l)})\\tag8$$ 损失函数关于权重和偏置的偏导分别为：$$\\frac{\\partial C}{\\partial W_{ij}^{(l)}} = a_i^{(l-1)}\\delta_i^{(l)}\\tag9$$$$\\frac{\\partial C}{\\partial b_{i}^{(l)}} =\\delta_i^{(l)}\\tag{10}$$ 误差根据8式由输出层向后传播，再结合1，2，9，10四式对权重和偏置进行更新 5.实现下面是一个简单3隐层神经网络的实现 In [ ]: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167import numpy as npdef loss(pred, y): return np.sum((pred - y) ** 2)def loss_prime(pred, y): return pred - yclass network: def __init__(self, input_size, hidden_size, num_layers, output_size, loss = loss, loss_prime = loss_prime): self.input_size = input_size self.hidden_size = hidden_size self.num_layers = num_layers self.output_size = output_size # activation function self.activation = self.sigmoid # derivative of activation function self.activation_prime = self.sigmoid_prime # loss funciton self.loss = loss # derivative of loss function self.loss_prime = loss_prime # input-&gt;hidden self.w_ih = np.random.randn(input_size, hidden_size) self.b_ih = np.random.randn(1, hidden_size) # hidden layers self.W_hh = [np.random.randn(hidden_size, hidden_size) for _ in range(num_layers - 1)] self.B_hh = [np.random.randn(1, hidden_size) for _ in range(num_layers - 1)] # hidden-&gt;output self.w_ho = np.random.randn(hidden_size, output_size) self.b_ho = np.random.randn(1, output_size) # assemble w and b self.W = [self.w_ih] self.W.extend(self.W_hh) self.W.append(self.w_ho) self.B = [self.b_ih] self.B.extend(self.B_hh) self.B.append(self.b_ho) # activation def sigmoid(self, x): return 1.0 / (1 + np.exp(-x)) def sigmoid_prime(self, x): return self.sigmoid(x) * (1 - self.sigmoid(x)) # forward pass, calculate the output of the network def forward(self, a): for w, b in zip(self.W, self.B): a = self.activation(np.dot(a, w) + b) return a # backpropagate error def backward(self, x, y): delta_w = [np.zeros(w.shape) for w in self.W] delta_b = [np.zeros(b.shape) for b in self.B] # get output of each layer in forward pass out = x outs = [] zs = [] for w, b in zip(self.W, self.B): z = np.dot(out, w) + b zs.append(z) out = self.activation(z) outs.append(out) # δ of last layer delta = self.loss_prime(outs[-1], y) * self.activation_prime(zs[-1]) delta_b[-1] = delta delta_w[-1] = np.dot(outs[-2].transpose(), delta) for i in range(2, len(delta_w)): delta = np.dot(delta, self.W[-i+1].transpose()) * self.activation_prime(zs[-i]) delta_b[-i] = delta delta_w[-i] = np.dot(outs[-i-1].transpose(), delta) return delta_w, delta_b # update w and b def update(self, batch, lr): delta_w = [np.zeros(w.shape) for w in self.W] delta_b = [np.zeros(b.shape) for b in self.B] for x, y in batch: d_w, d_b = self.backward(x, y) delta_w = [a + b for a, b in zip(delta_w, d_w)] delta_b = [a + b for a, b in zip(delta_b, d_b)] self.W = [w - lr * t for w, t in zip(self.W, delta_w)] self.B = [b - lr * t for b, t in zip(self.B, delta_b)] # SGD training def train(self, train_data, epochs, batch_size, lr): for i in range(epochs): np.random.shuffle(train_data) batches = [train_data[t : t + batch_size] for t in range(0, len(train_data), batch_size)] for batch in batches: self.update(batch, lr) loss = 0 for x, y in train_data: loss += self.loss(self.forward(x), y) loss /= len(train_data) print(\"Epoch %d done, loss: %f\" % (i + 1, loss)) # predict def predict(self, x): return self.forward(x)# use it for handwriting digits classificationimport tensorflow as tfmnist = tf.keras.datasets.mnistdef onehot(y): arr = np.zeros([y.shape[0], 10]) for i in range(y.shape[0]): arr[i][y[i]] = 1 return arr(x_train, y_train),(x_test, y_test) = mnist.load_data()x_train, x_test = x_train / 255.0, x_test / 255.0x_train = x_train.reshape([-1, 28 * 28])x_test = x_test.reshape([-1, 28 * 28])y_train = onehot(y_train)y_test = onehot(y_test)train_data = [t for t in zip(x_train, y_train)]test_data = [t for t in zip(x_test, y_test)]input_size = 28 * 28hidden_size = 100num_layers = 3output_size = 10net = network(input_size, hidden_size, num_layers, output_size)lr = 0.005epochs = 100batch_size = 100net.train(train_data, epochs, batch_size, lr)def softmax(x): exp = np.exp(x) return exp / np.sum(exp)correct = 0for x, y in test_data: ret = net.forward(x) pred = softmax(ret) if np.argmax(pred) == np.argmax(y): correct += 1acc = float(correct) / len(test_data)print('test accuracy: ', acc)","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"http://clusters.zju.edu.cn/tags/Tech/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://clusters.zju.edu.cn/tags/Machine-Learning/"}],"author":"陈岩"},{"title":"Distributed Tensorflow","slug":"tensorflow","date":"2018-12-23T11:57:25.000Z","updated":"2019-05-12T02:30:58.519Z","comments":true,"path":"2018/12/23/tensorflow/","link":"","permalink":"http://clusters.zju.edu.cn/2018/12/23/tensorflow/","excerpt":"","text":"Distributed Tensorflow1.单机log_device_placement单机情况比较简单，不需要特殊配置，TensorFlow会自动将计算任务分配到可用的GPU上，在定义session时，可以通过log_device_placement参数来打印具体的计算任务分配： 123456789import tensorflow as tfa = tf.constant([1.0, 2.0, 3.0], shape=[3], name='a')b = tf.constant([1.0, 2.0, 3.0], shape=[3], name='b')c = a + bwith tf.Session(config = tf.ConfigProto(log_device_placement = True)) as sess: sess.run(tf.global_variables_initializer()) print(sess.run(c)) 指定设备如果需要让一些运算在特定的设备上执行，可以使用tf.device: 1234567891011import tensorflow as tfwith tf.device('/cpu:0'): a = tf.constant([1.0, 2.0, 3.0], shape=[3], name='a') b = tf.constant([1.0, 2.0, 3.0], shape=[3], name='b')with tf.device('/gpu:0'): c = a + bwith tf.Session(config = tf.ConfigProto(log_device_placement = True)) as sess: sess.run(tf.global_variables_initializer()) print(sess.run(c)) 环境变量尽管上面一个例子中我们只给CPU和GPU0指定了计算任务，但是两块显卡的显存都被占满了： 因为TensorFlow会默认占满所有可见GPU的显存，对于简单的计算任务，这样显然非常浪费，我们可以通过修改环境变量CUDA_VISIBLE_DEVICES解决这个问题: 12# 运行时指定环境变量CUDA_VISIBLE_DEVICES=0 python demo.py 1234# Python 代码中修改环境变量import osos.environ['CUDA_VISIBLE_DEVICES']='0'... 2.多机In-graph &amp; Between-graphTensorFlow的分布式训练有两种模式：In-graph和Between-graph In-graph: 不同的机器执行计算图的不同部分，和单机多GPU模式类似，一个节点负责模型数据分发，其他节点等待接受任务，通过tf.device(“/job:worker/task:n”)来指定计算运行的节点 Between-graph:每台机器执行相同的计算图 Author: 陈岩PostDate: 2018.12.21","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"http://clusters.zju.edu.cn/tags/Tech/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://clusters.zju.edu.cn/tags/Tensorflow/"}],"author":"陈岩"},{"title":"Quick Guide to CUDA Profiling","slug":"cuprof","date":"2018-12-07T15:48:33.000Z","updated":"2019-05-12T02:30:58.510Z","comments":true,"path":"2018/12/07/cuprof/","link":"","permalink":"http://clusters.zju.edu.cn/2018/12/07/cuprof/","excerpt":"","text":"1. Brief Introduction在并行计算领域，很难通过纯理论的分析来确定程序的性能，GPGPU这种基于特定计算架构的计算任务更甚。事实上，很多制约并行算法性能的瓶颈很可能不在算法本身（比如资源调度障碍）。因此，对给定程序进行充分的性能测试与后续分析是相当必要的调优方法。 Nvidia提供了nvprof，nvvp，Nsight三种cuda可用的性能分析工具，本文将简述配合使用nvprof与nvvp的cuda程序性能分析方法。 2. Check Out Device Properties由于cuda程序的线程/块分配方案与程序运行的的硬件高度相关，故对目标平台的硬件参数有一定程度的了解是相当有必要的。我们可以使用cudaGetDeviceProperties()函数获取设备的各项属性，下述代码可以结合cuda_runtime_api.h#1218处struct cudaDeviceProp的定义和各属性的相应注解自行理解。 12345678int nDevices;cudaDeviceProp prop;cudaGetDeviceCount( &amp;nDevices );for ( auto i = 0; i != nDevices; ++i )&#123; cudaGetDeviceProperties( &amp;prop, i ); // check out interesting property&#125; 3. Profile Using Nvprof3.1. Quick Start1nvprof --help 3.2. Metrics 使用--query-metrics列出所有可测试的性能指标。 使用--metrics sm_efficiency,warp_execution_efficiency,...指定要测试的性能指标。 3.3. PC Sampling在CC5.2或更高的设备上支持使用PC采样(PC sampling)技术。 PC采样技术通过Round-Robin方法对SM中所有活动线程束的PC状态进行采样，采样结果包含如下两种可能： 线程束完成了当前指令。 线程束被stall，不能完成当前指令，并可以给出stall的原因。 事实上线程束被stall并不代表指令流水线处于stall状态，因为其他正常运行的线程束可以利用计算资源。 CC6.0以上的设备对PC采样方法进行了改进，通过检查线程束调度器是否执行指令来确定指令流水线是否真正处于stall状态，从而能正确指示指令stall的原因。 4. Data Visualize Using Nvvpnvvp可以导入nvprof的分析结果，可视化显示统计图表，并且建议性地指出程序可能存在的瓶颈。 以饼状图显示各类stall比重 以频谱显示各类指令比例 通过source file mapping可视化指令stall状态，需要在编译选项中指定-lineinfo 4.1. Usage12nvprof -f --kernels \"kernelName\" --analysis-metrics -o a.nvvp &lt;task&gt; &lt;args&gt;nvvp a.nvvp 这里我使用的方法是在集群上用nvprof做性能测试，之后将分析结果*.nvvp传回本地用nvvp做可视化。 Ext. RemarksTradeoff Between Registers and Threads在实际Profiling中重新认识了这个问题。 在默认情况下，nvcc为每个线程分配maxRegsPerThread个数的寄存器，在Tesla K40上，这个值为64。同时，每个SM持有为65536个寄存器，这意味着单个SM中的线程数最多不超过1024。通过检查参数表，我们发现该设备单个SM可容纳线程数为2048。这意味着我们计算任务的GPU利用率最大只有50%（所有SM均满载的状态下）。 在这种情况下，如果我们将分配给单个线程的寄存器数目减半，则最大GPU利用率可以达到100%。但若发生寄存器溢出（register spilling），溢出的存储空间被放到片外的local memory，访问速度在（同在片外的）global memory级别。 在实际的CUDA核函数中，能全部利用64个寄存器的情况很少。寄存器的使用情况可以在nvvp中检查，如果发现有大量寄存器浪费，可以立即减少寄存器数量。在大多数情况下，可以结合计算任务的量级和性质来调节线程最大寄存器数，从而达到有针对性的性能调优。 在nvcc中指定单个线程最大寄存器数，可以添加编译选项-maxrregcount=N。如果限定不修改编译选项或需要逐核函数指定，则需要使用__launch_bounds__限定符，如下（隐式地指定了最大寄存器个数）： 123456__global__ void__launch_bounds__(maxThreadsPerBlock, minBlocksPerMultiprocessor)MyKernel(...)&#123; ...&#125; 在我的path tracer中对上述方法进行测试，将每线程的寄存器数减半为32，SM线程数加倍并满载，GPU利用率由30+提升到70+，执行速度有1.5倍左右的提升。 Tradeoff Between BlockDim and BlockPerSM当一个块（block）中的所有线程束（warp）全部完成时，这个块才可以被SM调度。如果块的大小过大，则块的运行速度受单个线程束约束的开销就越大（如果算法并行度很高，增大块的大小不失为一个好选择）；如果块的大小过小，则一方面SM可能无法达到其最大利用率（受maxBlocksPerSM的限制），另一方面SM调度块的额外开销也会增大。尤其是针对不同特点的计算任务有不同的更优选择，如divergency较高的任务更适合较小的BlockDim。所以在选择BlockDim时不仅要在算法的适应性上做考虑，还要通过多次性能测试来进行针对性的优化。 Beware of Ladder Effects注意计算资源分配时要注意分配的资源量要能够被组别整除，否则会出现断层状的资源浪费现象。 每块线程数与SM中最大线程束数的关系","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"http://clusters.zju.edu.cn/tags/Tech/"},{"name":"CUDA","slug":"CUDA","permalink":"http://clusters.zju.edu.cn/tags/CUDA/"},{"name":"Profile","slug":"Profile","permalink":"http://clusters.zju.edu.cn/tags/Profile/"}],"author":"小妹妹"},{"title":"CUDA内存管理总结(一)","slug":"cuda","date":"2018-11-24T16:46:08.000Z","updated":"2019-05-12T02:30:58.505Z","comments":true,"path":"2018/11/25/cuda/","link":"","permalink":"http://clusters.zju.edu.cn/2018/11/25/cuda/","excerpt":"","text":"CUDA 内存管理(一)一、寄存器​ GPU的每个SM（流多处理器）都有上千个寄存器，每个SM都可以看作是一个多线程的CPU核，但与一般的CPU拥有二、四、六或八个核不同，一个GPU可以有N个SM核；同样，与一般的CPU核支持一到两个硬件线程不同，每个SM核可能有8~192个SP（流处理器），亦即每个SM能同时支持这么多个硬件线程。事实上，一台GPU设备的所有SM中活跃的线程数目通常数以万计。 1.1 寄存器映射方式​ CPU处理多线程：进行上下文切换，使用寄存器重命名机制，将当前所有寄存器的状态保存到栈（系统内存），再从栈中恢复当前需要执行的新线程在上一次的执行状态。这些操作通常花费上百个CPU时钟周期，有效工作吞吐量低。 ​ GPU处理多线程：与CPU相反，GPU利用多线程隐藏了内存获取与指令执行带来的延迟；此外，GPU不再使用寄存器重命名机制，而是尽可能为每个线程分配寄存器，从而上下文切换就变成了寄存器组选择器（或指针）的更新，几乎是零开销。 1.2 寄存器空间大小​ 每个SM可提供的寄存器空间大小分别有8KB、16KB、32KB和64KB，每个线程中的每个变量占用一个寄存器，因而总共会占用N个寄存器，N代表调度的线程数量。当线程块上的寄存器数目是允许的最大值时，每个SM会只处理一个线程块。 1.3 SM调度线程、线程块​ 由于大多数内核对寄存器的需求量很低，所以可以通过降低寄存器的需求量来增加SM上线程块的调度数量，从而提高运行的线程总数，根据线程级并行“占用率越高，程序运行越快”，可以实现运行效率的优化。当线程级并行（Thread-Level Parallelism，TLP）足以隐藏存储延迟时会达到一个临界点，此后想要继续提高程序性能，可以在单个线程中实现指令级的并行（Instruction-Level Parallelism，ILP），即单线程处理多数据。 ​ 但在另一方面，每个SM所能调度的线程总量是有限制的，因此当线程总量达到最大时，再减少寄存器的使用量就无法达到提高占有率的目的（如下表中寄存器数目由20减小为16，线程块调度数量不变），所以在这种情况下，应增加寄存器的使用量到临界值。 1.4 寄存器优化方式​ 1）将中间结果累积在寄存器而非全局内存中。尽量避免全局内存的写操作，因为如果操作聚集到同一块内存上，就会强制硬件对内存的操作序列化，导致严重的性能降低； ​ 2）循环展开。循环一般非常低效，因为它们会产生分支，造成流水线停滞。 1.5 总结​ 使用寄存器可以有效消除内存访问，或提供额外的ILP，以此实现GPU内核函数的加速，这是最为有效的方法之一。 二、共享内存2.1 基本概念​ 1、共享内存实际上是可以受用户控制的一级缓存，每个SM中的一级缓存和共享内存共用一个64KB的内存段。 ​ 2、共享内存的延迟很低，大约有1.5TB/s的带宽，而全局内存仅为160GB/s，换言之，有效利用共享内存有可能获得7倍的加速比。但它的速度依然只有寄存器的十分之一，并且共享内存的速度几乎在所有GPU中都相同，因为它由核时钟频率驱动。 ​ 3、只有当数据重复利用、全局内存合并，或者线程之间有共享数据（例如同时访问相同地址的存储体）的时候使用共享内存才更合适，否则将数据直接从全局内存加载到寄存器性能会更好。 ​ 4、共享内存是基于存储体切换的架构（bank-switched architecture），费米架构的设备上有32个存储体。无论有多少线程发起操作，每个存储体每个周期只执行一次操作。因此，如果线程束中的每个线程各访问一个存储体，那么所有线程的操作都可以在一个周期内同时执行，且所有操作都是独立互不影响的。此外，如果所有线程同时访问同一地址的存储体，会触发一个广播机制到线程束中的每个线程中。但是，如果是其他的访问方式，线程访问共享内存就需要排队，即一个线程访问时，其他线程将阻塞闲置。因此很重要的一点时，应该尽可能地获得零存储体冲突的共享内存访问。 2.2 Example：使用共享内存排序2.2.1 归并排序​ 假设待排序的数据集大小为N，现将数据集进行划分。根据归并排序的划分原则，最后每个数据包中只有两个数值需要排序，因此，在这一阶段，最大并行度可达到 $N \\over 2$ 个独立线程。例如，处理一个大小为512KB的数据集，共有128K个32位的元素，那么最多可以使用的线程个数为64K个（N=128K，N/2=64K），假设GPU上有16个SM，每个SM最多支持1536个线程，那么每个GPU上最多可以支持24K个线程，因此，按照这样划分，64K的数据对只需要2.5次迭代即可完成排序操作。 ​ 但是，如果采用上述划分排序方式再进行合并，我们需要从每个排好序的数据集中读出元素，对于一个64K的集合，需要64K次读操作，即从内存中获取256MB的数据，显然当数据集很大的时候不合适。 ​ 因此，我们采用通过限制对原始问题的迭代次数，通过基于共享内存的分解方式来获得更好的合并方案。因为在费米架构的设备上有32个存储体，即对应32个线程，所以当需要的线程数量减少为32（一个线程束）时，停止迭代，于是共需要线程束4K个（128K/32=4K），又因为GPU上有16个SM，所以这将为每个SM分配到256个线程束。然而由于费米架构设备上的每个SM最多只能同时执行48个线程束，因此多个块将被循环访问。 ​ 通过将数据集以每行32个元素的方式在共享内存中进行分布，每列为一个存储体，即可得到零存储体冲突的内存访问，然后对每一列实施相同的排序算法。（或者也可以理解为桶排序呀） ​ 然后再进行列表的合并。 2.2.2 合并列表​ 先从串行合并任意数目的有序列表看起： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void merge_array(const u32 *const src_array, //待排序数组 u32 *const dest_array, //排序后的数组 const u32 num_lists, //列表总数 const u32 num_elements) //数据总数&#123; const u32 num_elements_per_list = (num_elements / num_lists);//每个列表中的数据个数 u32 list_indexes[MAX_NUM_LISTS]; //所有列表当前所在的元素下标 for(u32 list = 0; list &lt; num_lists; list++) &#123; list_indexes[list] = 0; &#125; for(u32 i = 0; i&lt;num_elements; i++) &#123; dest_array[i] = find_min(scr_array, list_indexes, num_lists, num_elements_per_list); &#125;&#125;u32 find_min(const u32*cosnt src_array, u32 *const list_indexes, const u32 num_lists, const u32 num_elements_per_list)//寻找num_lists个元素中的最小值&#123; u32 min_val = 0xFFFFFFFF; u32 min_idx = 0; for(u32 i = 0; i &lt; num_lists; i++) &#123; if(list_indexes[i] &lt; num_elements_per_list) &#123; const u32 src_idx = i + (list_indexes[i]*num_lists); const u32 data = src_array[src_idx]; if(data &lt;= min_val) &#123; min_val = data; min_idx = i; &#125; &#125; &#125; list_indexes[min_idx]++; return min_val;&#125; ​ 将上述算法用GPU实现 123456789101112__global__ void gpu_sort_array_array(u32 *const data, const u32 num_lists, const u32 num_elements)&#123; const u32 tid = (blockIdx.x * blockDim.x) + threadIdx.x; __shared__ u32 sort_tmp[NUM_ELEM]; __shared__ u32 sort_tmp_1[NUM_ELEM]; copy_data_to_shared(data, sort_tmp, num_lists, num_elements, tid); radix_sort2(sort_tmp, num_lists, num_elements, tid, sort_tmp_1); merge_array6(sort_tmp, data, num_lists, num_elements, tid);&#125; ​ 第一个函数的实现： 123456789101112__device__ void copy_data_to_shared(const u32 *const data, u32 *sort_tmp, const u32 num_lists, const u32 num_elements, const u32 tid)&#123; for(u32 i = 0; i &lt; num_elements; i++) &#123; sort_tmp[i+tid] = data[i+tid]; &#125; __syncthreads();&#125; ​ 该函数中，程序按行将数据从全局内存读入共享内存。当函数调用一个子函数并传入参数时，这些参数必须以某种方式提供给被调用的函数，有两种方法可以采用。一种是通过寄存器传递所需的值，另一种方法是创建一个名为“栈帧”的内存区，但这种方法非常地不高效。出于这一原因，我们需要重新修改合并的程序(merge_array)，以避免函数调用，修改后程序如下（单线程）： 1234567891011121314151617181920212223242526272829303132333435363738__device__ void merge_array1(const u32 *const src_array, u32 *const dest_array, const u32 num_lists, const u32 num_elements, const u32 tid)&#123; __shared__ u32 list_indexes[MAX_NUM_LISTS]; lists_indexes[tid] = 0;//从每个列表的第一个元素开始 __syncthreads(); //单线程 if(tid == 0) &#123; const u32 num_elements_per_list = (num_elements / num_lists); for(u32 i = 0; i &lt; num_elements; i++) &#123; u32 min_val = 0xFFFFFFFF; u32 min_idx = 0; for(u32 list = 0; list &lt; num_lists; list++) &#123; if(list_indexes[list] &lt; num_elements_per_list) &#123; const u32 src_idx = i + (list_indexes[i]*num_lists); const u32 data = src_array[src_idx]; if(data &lt;= min_val) &#123; min_val = data; min_idx = i; &#125; &#125; &#125; list_indexes[min_idx]++; dest_array[i]=min_val; &#125; &#125;&#125; ​ 这里只用一个线程进行合并，但显然，为了获得更好的性能，一个线程是远远不够的。因为数据被写到一个单一的列表中，所以多个线程必须进行某种形式的合作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162__device__ void merge_array6(const u32 *const src_array, u32 *const dest_array, const u32 num_lists, const u32 num_elements, const u32 tid)&#123; //每个列表分到的元素个数 const u32 num_elements_per_list = (num_elements / num_lists); //创建一个共享列表数组，用来储存当前线程所访问的列表元素下标 __shared__ u32 list_indexes[MAX_NUM_LISTS]; list_indexes[tid] = 0; //创建所有线程共享的最小值与最小值线程号 __shared__ u32 min_val; __shared__ u32 min_tid; __syncthreads(); for(u32 i=0; i&lt;num_elements; i++) &#123; u32 data; //如果当前列表还未被读完，则从中读取数据 if(list_indexes[tid] &lt; num_elements_per_list); &#123; //计算出当前元素在原数组中的下标 const u32 src_idx = tid + (list_indexes[tid] * num_lists); data = src_array[src_idx]; &#125; else &#123; data = 0xFFFFFFFF; &#125; //用零号线程来初始化最小值与最小值线程号 if(tid == 0) &#123; min_val = 0xFFFFFFFF; min_tid = 0xFFFFFFFF; &#125; __syncthreads(); //让所有线程都尝试将它们现在手上有的值写入min_val，但只有最小的数据会被保留 //利用__syncthreads()确保每个线程都执行了该操作 atomicMin(&amp;min_val, data); __syncthreads(); //在所有data==min_val的线程中，选取最小线程号写入min_tid if(min_val == data) &#123; atomicMin(&amp;min_tid, tid); &#125; __syncthreads(); //将满足要求的线程所在列表的当前元素往后移一位，进行下一轮比较 //并将筛选结果存入结果数组dest_array if(tid == min_tid) &#123; list_indexes[tid]++; dest_array[i] = data; &#125; &#125;&#125; ​ 上面的函数中将num_lists个线程进行合并操作，但只用了一个线程一次将结果写入结果数据数组中，保证了结果的正确性，不会引起线程间的冲突。 ​ 其中使用到了 atomicMin 函数。每个线程以从列表中获取的数据作为入参调用该函数，取代了原先单线程访问列表中所有元素并找出最小值的操作。当每个线程调用 atomicMin 函数时，线程读取保存在共享内存中的最小值并于当前线程中的值进行比较，然后把比较结果重新写回最小值对应的共享内存中，同时更新最小值对应的线程号。然而，由于列表中的数据可能会重复，因此可能出现多个线程的值均为最小值的情况，保留的线程号却各不相同。因此需要执行第二步操作，保证保留的线程号为最小线程号。 ​ 虽然这种方法的优化效果很显著，但它也有一定的劣势。例如，atomicMin函数只能用在计算能力为1.2以上的设备上；另外，aotomicMin函数只支持整数型运算，但现实世界中的问题通常是基于浮点运算的，因此在这种情况下，我们需要寻找新的解决方法。 2.2.3 并行归约​ 并行归约适用于许多问题，求最小值只是其中的一种。它使用数据集元素数量一半的线程，每个线程将当前线程对应的元素与另一个元素进行比较，计算两者之间的最小值，并将得到的最小值移到前面。每进行一次比较，线程数减少一半，如此反复直到只剩一个元素为止，这个元素就是需要的最小值。 ​ 在选择比较元素的时候，应该尽量避免选择同一个线程束中的元素进行比较，因为这会明显地导致线程束内产生分支，而每个分支都将使SM做双倍的工作，继而影响程序的性能。因此我们选择将线程束中的元素与另一半数据集中的元素进行比较。如下图，阴影部分表示当前活跃的线程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071__device__ void merge_array5(const u32 *const src_array, u32 *const dest_array, const u32 num_lists, const u32 num_elements, const u32 tid)&#123; const u32 num_elements_per_list = (num_elements / num_lists); __shared__ u32 list_indexes[MAX_NUM_LISTS]; __shared__ u32 reduction_val[MAX_NUM_LISTS]; __shared__ u32 reduction_idx[MAX_NUM_LISTS]; list_indexes[tid] = 0; reduction_val[tid] = 0; reduction_idx[tid] = 0; __syncthreads(); for(u32 i=0; i&lt;num_elements; i++) &#123; u32 tid_max = num_lists &gt;&gt; 1;//最大线程数为列表总数的一半 u32 data;//使用寄存器可以提高运行效率，将对共享内存的写操作次数减少为1 //当列表中还有未处理完的元素时 if(list_indexes[tid] &lt; num_elements_per_list) &#123; //计算该元素在原数组中的位置 cosnst u32 src_idx = tid + (list_indexes[tid] * num_lists); data = src_array[src_idx]; &#125; //若当前列表已经处理完，将data赋值最大 else &#123; data = 0xFFFFFFFF; &#125; //将当前元素及线程号写入共享内存 reduction_val[tid] = data; reduction_idx[tid] = tid; __syncthreads; //当前活跃的线程数多于一个时 while(tid_max!=0) &#123; if(tid &lt; tid_max) &#123; //将当前线程中的元素与另一半数据集中的对应元素进行比较 const u32 val2_idx = tid + tid_max; const u32 val2 = reduction_val[val2_idx]; //最后保留较小的那个元素 if(reduction_val[tid] &gt; val2) &#123; reduction_val[tid] = val2; reduction_idx[tid] = reduction_idx[val_idx]; &#125; &#125; //线程数减半，进入下一轮循环 tid_max &gt;&gt;= 1; __syncthreads(); &#125; //在零号线程中将结果写入结果数组，并将相应线程所指的元素后移一位 if(tid == 0) &#123; list_indexes[reduction_idx[0]]++; dest_array[i] = reduction_val[0]; &#125; __syncthreads(); &#125;&#125; ​ 同样，这种方法也在共享内存中创建了一个临时的列表 list_indexes 用来保存每次循环中从 num_list 个数据集列表中选取出来进行比较的数据。如果进行合并的列表已经为空，那么就将临时列表中的对应数据区赋最大值0xFFFFFFFF。而每轮while循环后，活跃的线程数都将减少一半，直到最后只剩一个活跃的线程，亦即零号线程。最后将结果复制到结果数组中并将最小值所对应的列表索引加一，以确保元素不会被处理两次。 2.2.4 混合算法​ 在了解atomicMin函数和并行归约两种方案后，我们可以利用这两种算法各自的优点，创造出一种新的混合方案。 ​ 简单的1~N个数据归约的一个主要问题就是当N增大时，程序的速度先变快再变慢，达到最高效的情形时N在8至16左右。混合算法将原数据集划分成诸多个小的数据集，分别寻找每块中的最小值，然后再将每块得到的结果最终归约到一个值中。这种方法和并行归约的思想非常相似，但同时又省略了并行归约中的多次迭代。代码更新如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#define REDUCTION_SIZE 8#define REDUCTION_SIZE_BIT_SHIFT 3#define MAX_ACTIVE_REDUCTIONS ((MAX_NUM_LISTS) / (REDUCTION_SIZE))__device__ void merge_array(const u32 *const src_array, u32 *const dest_array, const u32 num_lists, const u32 num_elements, const u32 tid)&#123; //每个线程都从原数组中读入一个数据，用作首次比较 u32 data = src_array[tid]; //当前线程所在的数据块编号（8个线程为一组，每个线程处理一个列表） const u32 s_idx = tid &gt;&gt; REDUCTION_SIZE_BIT_SHIFT; //首次进行分别归约的数据块总数 const u32 num_reductions = num_lists &gt;&gt; REDUCTION_SIZE_BIT_SHIFT; const u32 num_elements_per_list = num_elements / num_lists; //在共享内存中创建一个列表，指向每个线程当前所在的元素，并初始化为0 __shared__ u32 list_indexes[MAX_NUM_LISTS]; list_indexes[tid] = 0; //遍历所有数据 for(u32 i=0; i&lt;num_elements; i++) &#123; //每个数据块在内部归约后都会产生一个相应的最小值 //在共享内存中开辟一个列表，用来保存每组的最小值 __shared__ u32 min_val[MAX_ACTIVE_REDUCTIONS]; __shared__ u32 min_tid; //初始化每个数据块的内部最小值 if(tid &lt; num_lists) &#123; min_val[s_idx] = 0xFFFFFFFF; min_tid = 0xFFFFFFFF; &#125; __syncthreads(); //将当前线程的数据与所处数据块的最小值进行比较，并保留较小的那一个 atomicMin(&amp;min_val[s_idx], data); //进行归约的数据块总数不为零时 if(num_reductions &gt; 0) &#123; //确保每个线程都已经将上一步比较操作完成 __syncthreads(); //将每个数据块产生的最小值与零号数据块的最小值进行比较，保留较小的那一个 if(tid &lt; num_reductions) &#123; atomicMin(&amp;min_val[0], min_val[tid]); __syncthreads(); &#125; //如果当前线程的数据等于此次比较保留的最小值，记录最小线程号 if(data == min_val[0]) &#123; atomicMin(&amp;min_tid, tid); &#125; //确保上一步操作每个线程都已经完成，才能执行下一句 __syncthreads(); //如果当前线程号恰为记录下的最小线程号 if(tid == min_tid) &#123; //当前所指元素后移一位 list_indexes[tid]++; //将结果保存入结果数组 dest_array[i] = data; //若该线程对应的列表尚未被处理完 if(list_indexes[tid] &lt; num_elements_per_list) //更新该线程的data，进行下一轮比较 data = src_array[tid + (list_indexes[tid] * num_lists)]; else data = 0xFFFFFFFF; &#125; __syncthreads(); &#125; &#125;&#125; ​ 注意到： ​ 1）原来的min_val由单一的数据扩展成为一个共享数据的数组，这是因为每个独立的线程都需要从它对应的数据集中获取当前的最小值来进行内部比较。每个最小值都是一个32位的数值，因此可以存储在独立的共享内存存储体中。 ​ 2）内核函数中的REDUCTION_SIZE的值被设置成8，意味着每个数据块中包含8个数据，程序分别找出每个数据块的最小值，然后再在这些最小值中寻找最终的最小值。 ​ 3）内核函数中最重要的一个变化是，只有每次比较的最小值所对应的那个线程的data才会更新，其他线程的data都不会更新。而在之前的内核函数中，每轮比较开始，所有线程都会从对应的列表中重新读入data 的值，随着N的增大，这将变得越来越低效。 2.2.5 总结​ 1）共享内存允许同一个线程块中的线程读写同一段内存，但线程看不到也无法修改其他线程块的共享内存。 ​ 2）共享内存的缓冲区驻留在物理GPU上，所以访问时的延迟远低于访问普通缓冲区的延迟，因此除了使用寄存器，还应更有效地使用共享内存，尤其当数据有重复利用，或全局内存合并，或线程间有共享数据的时候。 ​ 3）编写代码时，将关键字_shared__添加到声明中，使得该变量留驻在共享内存中，并且线程块中的每个线程都可以共享这块内存，使得一个线程块中的多个线程能够在计算上进行通信和协作。 ​ 4）调用 __syncthreads() 函数来实现线程的同步操作，尤其要注意确保在读取共享内存之前，想要写入的操作都已经完成。另外还需要注意，切不可将这个函数放置在发散分支（某些线程需要执行，而其他线程不需要执行），因为除非线程块中的每个线程都执行了该函数，没有任何线程能够执行之后的指令，从而导致死锁。 ​ 5）不妨尝试使用共享内存实现矩阵乘法的优化。 Author: 潘薇鸿PostDate: 2018.11.25","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"http://clusters.zju.edu.cn/tags/Tech/"},{"name":"CUDA","slug":"CUDA","permalink":"http://clusters.zju.edu.cn/tags/CUDA/"}],"author":"潘薇鸿"},{"title":"浙江大学超算队博客...活了？","slug":"first","date":"2018-09-30T13:25:55.000Z","updated":"2019-05-12T02:30:58.517Z","comments":true,"path":"2018/09/30/first/","link":"","permalink":"http://clusters.zju.edu.cn/2018/09/30/first/","excerpt":"","text":"写在前面这里是浙江大学超算队的官方博客 记录一些前沿的Tech姿势、大家平时的DeBug经历、还有ASC世界超算大赛的经验分享！ 希望这个博客不仅仅是给以后的小盆友们提供宝贵的经验 更是诸君技术的记录与提升的大好机会 平时我们写着代码 总是不愿意写文档 遇到了非常Tricky又神奇的Bug 花了一下午终于解决了 却没有记录下来 很有可能很多的无谓的时间就会在以后被重复 这样的时间浪费 我们完全可以节省下来！ 希望大家能享受在超算队一起学习的时光~ 从现在开始 把这段美好的时间变成字符 记录下来叭~~ Author: TTfishPostDate: 2018.9.30","categories":[],"tags":[{"name":"Tech","slug":"Tech","permalink":"http://clusters.zju.edu.cn/tags/Tech/"},{"name":"Spc","slug":"Spc","permalink":"http://clusters.zju.edu.cn/tags/Spc/"},{"name":"ZJU","slug":"ZJU","permalink":"http://clusters.zju.edu.cn/tags/ZJU/"}],"author":"TTfish"}]}