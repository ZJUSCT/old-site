---
title: RSA加密算法及其数学思想
date: 2019-06-21 
author: 漆翔宇
tags: 
    - 密码学
    - 数论
---





# RSA加密算法及其数学思想

像DES以及AES还有那些经典的古典加密算法，都属于对称密码体制，加密和解密必须要使用同一套密钥。这样一套对称的密码系统，发送信息和接收信息的双方都要掌握这个密钥才能加密和解密，任何一方泄露了密钥，数据的安全就会遭到威胁。

RSA算法是1977年由Ron Rivest, Adi Shamir, Leonard Adleman提出的公钥密码体制(public-key cryptosystem)，公钥密码体制也称非对称密码体制(asymmetric cryptosystem)。

在公钥密码体制中，加密密钥与解密密钥是不同的，加密密钥简称公钥(public key)，是可以公开的，解密密钥简称私钥(private key)，是需要被保护的。

在一些场合下，比如说消息接收者在一个安保措施非常好的军事中心，而消息发送者是散布在世界各地的探员，我们可以只告诉这些探员公钥，他们只知道如何利用它加密，而不知道如何解密，就算被抓了，也无法威胁这套加密系统的安全性，因为能破译这些消息的人只有受到严格保护的拥有私钥的人。这也是这套非对称加密系统的强大之处。

看了看网上很多关于RSA的文章，也看了白洪欢的密码学讲义，甚至还翻了翻《离散数学及其应用》，发现对RSA的讲解都是证明完其正确性就点到为止了。

但是显然RSA的精髓是其构造过程，其设计思想。在我看来，光证明其正确性没有任何意义。除了知道它是对的，不能带来任何收获。

这篇文章除了简单的介绍RSA算法的过程，并对其正确性做一个数学证明，还会从构造法的角度仔细讨论RSA的核心设计思路。这个思路并不复杂，只要对基本的数论知识有所了解，就很容易顺着逻辑走通。文章会涉及到一些比较基础的数论知识，如果对相关知识不太熟悉，可以参考：[RSA中的数论知识](http://www.unispac.xyz/?p=1558)。





## 基本模式

* 随机选择两个不等的大素数p和q。
* 计算出n=p*q。
* 挑选一个数e，使得它和(p-1)(q-1)互素。
* 计算e在模(p-1)(q-1)意义下的逆元d。
* 公开（e,n）作为公钥。
* 保留（d,n）作为私钥。

* 加密一个数M：$Cipher=M^e\ \ (mod\ n)$

* 解密一条密文：$Plaintext=Cipher^d\ \ (mod\ n)$





## 分析

RSA算法保证：在公开e和n的情况下，对于满足一定条件（小于n，不被p和q整除）的M，任何人都可以通过$Cipher=M^e \ mod\ n$ 来对M加密。通过保存的私钥d可以恢复：$Plaintext=Cipher^d\equiv M\ (mod\ n)$。

RSA中，n是两个大素数p和q的乘积，e是挑选出来的一个与(p-1)(q-1)互素的数e，d是e在模(p-1)(q-1)意义下的乘法逆元。

这个设计非常的讲究，要理解其意义，我们先要能证明，上述解密变换的正确性。



### 变换的正确性

$ M^{ed} \equiv M \ \ (mod \ n) $
$$
已知ed \equiv 1 \ [mod \ (p-1)(q-1)] 
$$

$$
则ed=k(p-1)(q-1)+1 
$$

$$
M^{ed}=M * M^{ k(p-1)(q-1) }
$$




*  由费马小定理：$ p为素数，若a不能被p整除，则a^{p-1} \equiv 1 \ (mod\ p) $

	

$$
则只要M既不是p也不是q的倍数：M^{ed} \equiv M \ (mod\ p) \ \ ; \ \ M^{ed} \equiv M \ (mod \ q)
$$

$$
M^{ed}-M \equiv 0 \ (mod \ p) 
$$

$$
M^{ed}-M \equiv 0 \ (mod \ q)
$$





* 由中国剩余定理：

$$
正整数m_1,m_2,m_3,......,m_n两两互素，a_1,a_2,a_3,......,a_n是任意整数。
$$

$$
x \equiv a_1 \ (mod\;m_1)
$$

$$
x \equiv a_2 \ (mod\;m_2)
$$

$$
......
$$

$$
x\equiv a_n(mod \ m_n)
$$

$$
有唯一的模m=m_1m_2......m_n的解。
$$

$$
令M_k=\frac{m}{m_k},M_k在模m_k意义下的乘法逆元为y_k[即M_ky_k\equiv1\;(mod\;m_k)]
$$

$$
x=a_1M_1y_1+...+a_nM_ny_n.
$$

$$
由于p和q互素。
$$

$$
因此，M^{ed}-M \equiv 0 * (..) + 0 * (..) \equiv 0 \ (mod\ n)
$$



**<font color=red> 				得证 $ M^{ed}\equiv M \ (mod\ n) $  </font>**

### 设计思想

前面我们给出了RSA正确性的简单证明，可以看到如何证明RSA的正确性并不是一件困难的事。但是会证明RSA的正确性，只能说明你知道RSA“为什么对”，但是你可能并无法理解其真正的设计思想。

在RSA的设计中，我们发现有两个关键的要素：大素数p和q，(p-1)(q-1)。既然取了n=pq，为什么还要取(p-1)(q-1)，为什么要取一个与之互素的e，逆元d又是为了什么？在我看来，只有能够回答上面这些问题，才能真正算得上对RSA有所理解。

这一小节，我们将会针对RSA的设计思想做一个简单的讨论。

* RSA非对称加密的核心特征

	其实RSA所谓的非对称无非就是利用了这样一个性质：
	$$
	M^{ed}\equiv M\ (mod\ n)
	$$
	这是一个怎样的性质呢？这其实就是一个恒等映射的性质：一个数字被幂函数变换后，总是等于自己。。。这里的函数$f(x)=x^{ed}$就是在模n的剩余系中的一个恒等映射罢了。

	恒等映射？恒等映射意味着什么呢？

	无论什么加密系统，对于加密函数$En(x)$和解密函数$De(x)$来说，它们的复合：$En \cdot De$ 其实都是恒等映射。。。反过来讲，任何一个恒等映射，只要能被写成一对函数复合的形式，那么这对函数就可以分别作为加密函数和解密函数。。。

	巧了，这里的$f(x)=x^{ed}$正好就可以做这样的分解：$x^e和x^d$。。。所以这对函数就能用来加解密。。

	传统的对称加密，使用的一对加解密函数依赖于相同的密钥。但是这里函数的参数e和d可能是不同的，因此加解密依赖不同的密钥，所以就是非对称的。

* 恒等映射怎么来的？

	了解了所谓的非对称加密的本质后。我们第二个问题自然是：这个恒等映射是怎样的？

	对于RSA，它采用了幂函数的形式。

	那么我们就来考察一下：幂函数的指数应该满足什么条件才能让这个映射在特定的剩余系中是一个恒等映射呢？
	$$
	a^x\equiv a\ (mod\ n)
	$$
	看到这个形式，很容易想到费马小定理，或者欧拉定理。

	前者给出：
	$$
	a^{p-1}\equiv1\ (mod\ p)
	$$
	后者给出:
	$$
	a^{\Phi(n)}\equiv 1\ (mod\ n)
	$$
	当然，很显然，前者是后者的一个特例。

	欧拉定理的条件很宽松，只要求a和n互素。而一般来说，n取一个素数，a如果小于n，那么这个条件一定满足。或者n的素因子很少，且都很大，a比任意一个素因子都小，那么这个条件也一定能满足。

	那么我们要构造这样的一个恒等映射再容易不过了，找一个比较好的n，指数x取$k*\Phi(n)+1$就行了。

* 如何分解？

	我们在一开始说了，一套密码系统，首先要有个恒等映射，其次这个恒等映射要可分解。

	所以对于我们找到的n，它的欧拉函数必须要保证 $k*\Phi(n)+1=ed$ 这样的分解是可操作的。

	换句话说：$ed\equiv1\ [mod\ \Phi(n)]$

	再换句话说，e和d再模$\Phi(n) $意义下互为乘法逆元？

	卧槽？这句话是不是很耳熟？RSA不是求了e在模(p-1)(q-1)意义下的逆元d么？

	但是你自己想想(p-1)(q-1)究竟是啥呢？

	$(p-1)(q-1)=\Phi(p)*\Phi(q)=\Phi(pq)=\Phi(n)$   

* 为啥e被要求和(p-1)(q-1)互素？

	这个在之前的[RSA中的数论知识](http://www.unispac.xyz/?p=1558)也讲过，当一个数和模数互素的时候，可以保证逆元存在且唯一。所以其实我们可以看到，这里强迫e与(p-1)(q-1)互素，就是为了保证在欧拉函数$\Phi(n) $为模的剩余中，存在这样一对乘法逆元。

* 既然n取一个大素数就可以很好的利用欧拉函数构造，为什么RSA还要用一对大素数的乘积作为n呢？

	思考这样一个问题：现在你用一个大素数作为n，那么显然它的欧拉函数$\Phi(n)=n-1$，你公钥里面给了e和n，我们知道d是e在模欧拉函数$\Phi(n) $意义下的乘法逆元，那么我有了n-1，有了e，求d还不是分分钟钟的事情。。。这个根本没什么加密能力。。

	于是我们退而求其：拿一个有两个大素数因子p和q的n来。现在n不是素数了，你有了e，还需要我的欧拉函数才能算出d。但是我的欧拉函数不再像素数那样就等于n-1了，要求我的欧拉函数，你必须得有我的两个素因子p和q。但是众所周知，大数的质因数分解是一个NP为题。嘿嘿嘿，现在你要破解就没那么容易了。

* 总结

	总结起来，RSA的思路无非可以整理成这样几点：

	1.我想要一个以剩余系为数域，形式为幂函数的加密系统。

	2.那么我需要一个可以分解的幂函数恒等映射。

	3.我发现这个恒等映射可以用欧拉函数构造。

	4.构造这个恒等映射的时候，模数n要选一个稍微好点的，最好是一个质数或者是一个质因数很少且很大的数。

	5.这个恒等映射还需要可分解。

	6.我发现，可分解其实等价于找一对$\Phi(n) $为模数的剩余系中的乘法逆元。这也并不是特别难的事情。。

	7.好了，现在我想明白了。拿个大素数作为n试试。构造倒是构造出来了，但是发现好像公开了e和n，d很容易就算出来了。

	8.那我再拿两个大素数的乘积作为n试试，现在我发现你好像要算出d必须得算出n的欧拉函数，而这必须先解决大数质因数分解，这是非常困难的，那么现在我的加密系统就显得非常安全了。

	9.然后你还会想到，显然n不一定非要是两个素因子p和q的乘积，我们还可以取多个大素数的乘积来作为n，也能达到类似的效果。

	

### 安全性

在设计思想中，我们已经梳理得很清楚了，RSA算法本质上利用了大数字质因数分解的困难性：对于一个N位的数字，对其进行质因数分解，时间复杂度都是关于N的指数数量级，不存在多项式复杂度的算法。



